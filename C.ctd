<?xml version="1.0" encoding="UTF-8"?>
<cherrytree>
  <bookmarks list=""/>
  <node name="Makefile" unique_id="1" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1707916051" ts_lastsave="1707916497">
    <rich_text scale="h1">Пример создания и связывания статической библиотеки.</rich_text>
    <rich_text>



</rich_text>
    <rich_text scale="h2">Описание:</rich_text>
    <rich_text>
</rich_text>
    <rich_text weight="heavy">stat_lib</rich_text>
    <rich_text> -&gt; вызывает </rich_text>
    <rich_text weight="heavy">stat</rich_text>
    <rich_text>.  
</rich_text>
    <rich_text weight="heavy">stat</rich_text>
    <rich_text> -&gt; компилируем func.c в func.o (в объектный файл).  
</rich_text>
    <rich_text weight="heavy">stat_lib</rich_text>
    <rich_text> -&gt; создаём статическую библиотеку libfunc_stat.a из func.o.  
</rich_text>
    <rich_text weight="heavy">obj_stat</rich_text>
    <rich_text> -&gt; связывает app_stat.o с библиотекой libfunc_stat.a для создания исполняемого файла app_stat.

</rich_text>
    <rich_text scale="h2">Дополнительно:</rich_text>
    <rich_text>
Автоматическое правило: make имеет встроенные правила для некоторых типов файлов. Для файлов с расширением .o, make знает, что они должны быть скомпилированы из соответствующих файлов с расширением .c с помощью компилятора C. Таким образом, если app_stat.c существует и app_stat.o не найден или устарел, make автоматически выполнит команду для его создания.

Имя файла статической библиотеки C не обязательно должно начинаться с «lib». Однако принято добавлять к имени префикс «lib», особенно при использовании этой -l опции во время связывания. Это связано с тем, что компоновщик ожидает, что библиотека будет названа в форме lib{name}.a для статических библиотек и lib{name}.soдля общих библиотек. Когда вы используете эту -l опцию с компоновщиком, он автоматически добавляет lib префикс и соответствующий суффикс (.a для статических библиотек) при поиске библиотеки. Например, если вы напишете -lfoo, компоновщик будет искать файл с именем libfoo.a. Если вы хотите использовать библиотеку, которая не соответствует lib соглашению о префиксах, вам придется указать полный путь к файлу библиотеки при связывании, не используя -l опцию.

-L. флаг, указывающий компоновщику искать библиотеки в текущем каталоге.  
Флаг -lfunc_stat для связывания с libfunc_stat.a библиотекой.

</rich_text>
    <rich_text scale="h2">Файлы проекта:</rich_text>
    <rich_text>

</rich_text>
    <rich_text scale="h3">app_stat.c:</rich_text>
    <rich_text>


</rich_text>
    <rich_text scale="h3">func.c:</rich_text>
    <rich_text>


</rich_text>
    <rich_text scale="h3">func.h:</rich_text>
    <rich_text>

</rich_text>
    <codebox char_offset="54" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="makefile" highlight_brackets="1" show_line_numbers="1">GCC = gcc -Wall -Werror -Wextra -std=c11
AR = ar rcs

all: rebuild

rebuild: clean stat_lib obj_stat

obj_stat: app_stat.o
	$(GCC) -L. -lfunc_stat -o app_stat app_stat.o

clean:
	rm -rf app
	rm -rf *.o
	rm -rf *.a
	rm -rf *.gch
	rm -rf app_stat

stat: func.c
	$(GCC) -c func.c -o func.o

stat_lib: stat
	$(AR) libfunc_stat.a func.o</codebox>
    <codebox char_offset="1649" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="c" highlight_brackets="1" show_line_numbers="0">#include&lt;stdio.h&gt;
#include"func.h"

int main() {
    printf("Hello static\n");
    my_print();
    return 0;
}</codebox>
    <codebox char_offset="1660" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="c" highlight_brackets="1" show_line_numbers="0">#include"func.h"

void my_print(){
    printf("Hello my func\n");
}</codebox>
    <codebox char_offset="1671" justification="left" frame_width="90" frame_height="100" width_in_pixels="0" syntax_highlighting="c" highlight_brackets="1" show_line_numbers="0">#include&lt;stdio.h&gt;

void my_print();</codebox>
  </node>
</cherrytree>
